<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="ZhangKing, 2532422112@qq.com"><title>codeforces#486 · Hexo</title><meta name="description" content="一套简单的div3http://codeforces.com/contest/988
A.Diverse Team题目连接
题目大意：给一个长度为n的数组，问你是否可以找出k个不同的数，如果可以的话把坐标输出出来
“””
#include&amp;lt;bits/stdc++.h&amp;gt;
using nam"><meta name="keywords" content="AI, ACM, Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Hexo</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="http://github.com/https://github.com/ZhangKingsasa"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>codeforces#486</a></h3></div><div class="post-content"><h2 id="一套简单的div3"><a href="#一套简单的div3" class="headerlink" title="一套简单的div3"></a>一套简单的div3</h2><p><a href="http://codeforces.com/contest/988" target="_blank" rel="noopener">http://codeforces.com/contest/988</a></p>
<h3 id="A-Diverse-Team"><a href="#A-Diverse-Team" class="headerlink" title="A.Diverse Team"></a>A.Diverse Team</h3><p><a href="http://codeforces.com/contest/988/problem/A" target="_blank" rel="noopener">题目连接</a></p>
<p>题目大意：给一个长度为n的数组，问你是否可以找出k个不同的数，如果可以的话把坐标输出出来</p>
<p>“””</p>
<p>#include&lt;bits/stdc++.h&gt;</p>
<p>using namespace std;<br>int a[101];<br>int main(){<br>    int n, m;<br>    scanf(“%d%d”, &amp;n, &amp;m);<br>    for(int i = 0; i &lt; n; i++){<br>        int x;<br>        scanf(“%d”, &amp;x);<br>        a[x] = i + 1;<br>    }<br>    int sum = 0;<br>    for(int i = 0; i &lt;= 100; i++){<br>        sum += (a[i] != 0);<br>    }<br>    if(sum &lt; m)printf(“NO\n”);<br>    else{<br>        printf(“YES\n”);<br>        int cnt = 0;<br>        for(int i = 0; i &lt; m; i++){<br>            while(a[cnt] == 0) cnt++;<br>            printf(“%d “, a[cnt]);<br>            cnt++;<br>        }<br>    }<br>}<br>“””</p>
<h3 id="B-Substrings-Sort"><a href="#B-Substrings-Sort" class="headerlink" title="B.Substrings Sort"></a>B.Substrings Sort</h3><p><a href="http://codeforces.com/contest/988/problem/B" target="_blank" rel="noopener">题目连接</a></p>
<p>题目大意：给你n个字符串，让你对这n个字符串进行排序，使得对于当前字符串是下一个字符串的子串，可以的话输出答案，不行的话输出-1。</p>
<p>题目思路：我们直接对长度进行排序，如果长度一样的话如果在满足条件的情况下这两个串必定相等，长度不一样的话短的一定是长的串的子串。</p>
<p>“””</p>
<p>#include&lt;bits/stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>vector<string> v;</string></p>
<p>int cmp(string a, string b){<br>    return a.size() &lt; b.size();<br>}</p>
<p>int main(){<br>    int n;<br>    scanf(“%d”, &amp;n);<br>    for(int i = 0; i &lt; n; i ++){<br>        string tmp;<br>        cin &gt;&gt; tmp;<br>        v.push_back(tmp);<br>    }<br>    sort(v.begin(), v.end(), cmp);<br>    int flag = 1;<br>    for(int i = 1; i &lt; v.size(); i++){<br>        if(v[i].find(v[i - 1]) == -1) flag = 0;<br>    }<br>    if(flag){<br>        printf(“YES\n”);<br>        for(int i = 0; i &lt; v.size(); i++){<br>            cout &lt;&lt; v[i] &lt;&lt; endl;<br>        }<br>    }<br>    else{<br>        printf(“NO\n”);<br>    }<br>}<br>“””</p>
<h3 id="C-Equal-Sums"><a href="#C-Equal-Sums" class="headerlink" title="C. Equal Sums"></a>C. Equal Sums</h3><p><a href="http://codeforces.com/contest/988/problem/C" target="_blank" rel="noopener">题目连接</a></p>
<p>题目大意：给n个序列，问你是否能从中选出两个序列，使得这两个序列中每一个序列删掉一个元素之后得到的和相等，满足输出两个序列的编号和删除的编号。</p>
<p>题目思路：对于一个序列假如有m个数，我们可以计算他删掉每个数之后得到的和，共有m个，然后我们用map存一下，如果发现重复的，直接输出就可以了。</p>
<p>“””</p>
<p>#include&lt;bits/stdc++.h&gt;</p>
<p>using namespace std;<br>vector<int> v[200005],c[200005];<br>int sum[200005];<br>map&lt;int, int&gt; vis;<br>int main(){<br>    int n;<br>    scanf(“%d”, &amp;n);<br>    for(int i = 0, x; i &lt; n; i++){<br>        scanf(“%d”, &amp;x);<br>        for(int j = 0; j &lt; x; j++){<br>            int tmp;<br>            scanf(“%d”, &amp;tmp);<br>            v[i].push_back(tmp);<br>            sum[i] += tmp;<br>        }<br>        for(int j = 0; j &lt; x; j++){<br>            int k = sum[i] - v[i][j];<br>            if(vis[k] &amp;&amp; vis[k] != i + 1){<br>                printf(“YES\n%d %d\n”, i + 1, j + 1);<br>                int cnt = vis[k];<br>                for(int l = 0; l &lt; c[cnt - 1].size(); l++){<br>                    if(c[cnt - 1][l] == k){<br>                        printf(“%d %d\n”, cnt, l + 1);<br>                        return 0;<br>                    }<br>                }<br>            }<br>            else{<br>                vis[k] = i + 1;<br>                c[i].push_back(k);<br>            }<br>        }<br>    }<br>    printf(“NO\n”);<br>    return 0;<br>}<br>“””</int></p>
<h3 id="D-Points-and-Powers-of-Two"><a href="#D-Points-and-Powers-of-Two" class="headerlink" title="D. Points and Powers of Two"></a>D. Points and Powers of Two</h3><p><a href="http://codeforces.com/contest/988/problem/D" target="_blank" rel="noopener">题目连接</a></p>
<p>题目大意：在一个一维坐标上有n个点，问你找到最大的子集，使得子集中任意两点的距离都是2的倍数</p>
<p>题目思路：我们经过仔细观察后发现，对于任意的x, y, z，如果这三个点满足条件，那么我再添任意一个点都将破坏关系，使得条件不成立，所以最大的答案就是3，我们枚举1,2,3,就好啦。</p>
<p>“””</p>
<p>#include&lt;bits/stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>long long a[300005];<br>map<long long,="" int="">m;<br>int main(){<br>    int n;<br>    scanf(“%d”, &amp;n);<br>    for(int i = 0; i &lt; n; i++){<br>        scanf(“%lld”, &amp;a[i]);<br>        m[a[i]] = 1;<br>    }<br>    sort(a, a + n);<br>    long long a1 = a[0], a2, a3, c = 1;<br>    for(int i = 0;i &lt; n - 1; i++){<br>        long long cnt = 1;<br>        while(a[i] + cnt &lt;= a[n - 1]){<br>            if(m[a[i] + cnt]){<br>                a1 = a[i];<br>                a2 = a[i] + cnt;<br>                c = 2;<br>                if(m[a[i] + 2<em>cnt]){<br>                    printf(“3\n%lld %lld %lld\n”, a1, a2, a[i] + 2</em>cnt);<br>                    return 0;<br>                }<br>            }<br>            cnt *= 2;<br>        }<br>    }<br>    printf(“%lld\n”, c);<br>    if(c - 1) printf(“%lld %lld\n”, a1, a2);<br>    else printf(“%lld\n”, a1);<br>}<br>“””</long></p>
<h3 id="E-Divisibility-by-25"><a href="#E-Divisibility-by-25" class="headerlink" title="E. Divisibility by 25"></a>E. Divisibility by 25</h3><p><a href="http://codeforces.com/contest/988/problem/E" target="_blank" rel="noopener">题目连接</a></p>
<p>题目大意：给你一个数字，你可以进行一种操作就是对于任意一位数字，你可以把它和他旁边的数字进行交换，问你最少交换几次，才可以得到25的倍数，(得到的数不含前导0)，如果得不到输出-1。</p>
<p>题目思路：我们发现对于25的倍数，只要是末尾是00,25,50,75这四种情况我们都可以进行整除，所以我们分别进行判断一下就可以，但是要注意前导0的情况，如果把前面的数挪到后面之后0在第一位了，那么我们还要把后面的数向前挪到第一位。</p>
<p>“””</p>
<p>#include&lt;bits/stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>char a[100];</p>
<p>int solve(int f, int e){<br>    int len = strlen(a);<br>    int ff = -1, ee = -1;<br>    for(int i = len - 1, k = 0; i &gt;= 0; i–, k++){<br>        if(a[i] - ‘0’ == e){<br>            a[i] = ‘9’;<br>            ee = k;<br>            break;<br>        }<br>    }<br>    for(int i = len - 1, k = 0; i &gt;= 0; i–, k++){<br>        if(a[i] - ‘0’ == f){<br>            a[i] = ‘9’;<br>            ff = k;<br>            break;<br>        }<br>    }<br>    if(ee != -1) a[len - ee - 1] = e + ‘0’;<br>    if(ff != -1) a[len - ff - 1] = f + ‘0’;<br>    int sum = 0;<br>    if(ff == len - 1){<br>        for(int i = 1; i &lt; len; i++){<br>            if(len - i - 1 == ee) continue;<br>            if(a[i] == ‘0’) sum++;<br>            else break;<br>        }<br>    }<br>    else if(ee == len - 1){<br>        for(int i = 1; i &lt; len; i++){<br>            if(len - i - 1 == ff) continue;<br>            if(a[i] == ‘0’) sum++;<br>            else break;<br>        }<br>    }<br>    if(ee == -1 || ff == -1)<br>        return 100;<br>    else if(ff &gt; ee){<br>        return ee + ff - 1 + sum;<br>    }<br>    else{<br>        return ee + ff + sum;<br>    }<br>}</p>
<p>int main(){<br>    scanf(“%s”, a);<br>    int len = strlen(a);<br>    int flag = 0;<br>    int mx = 100;<br>    mx = min(solve(0, 0), mx);<br>    mx = min(solve(2, 5), mx);<br>    mx = min(solve(5, 0), mx);<br>    mx = min(solve(7, 5), mx);<br>    if(mx == 100 || len &lt; 2){<br>        printf(“-1\n”);<br>    }<br>    else{<br>        printf(“%d\n”, mx);<br>    }<br>}<br>“””</p>
<h3 id="F-Rain-and-Umbrellas"><a href="#F-Rain-and-Umbrellas" class="headerlink" title="F. Rain and Umbrellas"></a>F. Rain and Umbrellas</h3><p><a href="http://codeforces.com/contest/988/problem/F" target="_blank" rel="noopener">题目连接</a></p>
<p>题目大意：小明现在在一个一维坐标上，他在0点，他现在想去找住在a点的小红玩，但是在0-a的区间会有n个子区间是下雨的，小明不想淋雨，在地上会有m把雨伞，分别在不同的位置，每一把雨伞有自己的权重，当小明选择拿起这把伞的时候，他每走一步则需要花费当前雨伞的权重，小明可以随时丢弃伞或者捡起伞，输出小明找到小红需要的最小化费，如果他必淋雨，则输出-1。</p>
<p>题目思路：<br>如果对于当前位置下雨，那么我们就向前找所有有雨伞的位置，维护对于走到当前位置所需花费的最小值，如果当前位置不下雨，最小值直接等于前一天就可以了。给的是子区间，是边，我们要把边化点。</p>
<p>“””</p>
<p>#include&lt;bits/stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>long long tag[2010], minn[2010], val[2010];</p>
<p>int main(){<br>    int a, n, m;<br>    scanf(“%d%d%d”, &amp;a, &amp;n, &amp;m);<br>    for(int i = 0; i &lt;= a; i++) minn[i] = val[i] = 1e9;<br>    for(int i = 0; i &lt; n; i++){<br>        int u, v;<br>        scanf(“%d%d”, &amp;u, &amp;v);<br>        tag[u + 1]++;<br>        tag[v + 1]–;<br>    }<br>    for(int i = 0; i &lt; m; i++){<br>        long long u, v;<br>        scanf(“%lld%lld”, &amp;u, &amp;v);<br>        val[u] = min(val[u], v);<br>    }<br>    int nw = tag[0]; minn[0] = 0;<br>    for(int i = 1; i &lt;= a; i++){<br>        nw += tag[i];<br>        if(nw){<br>            for(int j = i - 1; j &gt;= 0; j–){<br>                    minn[i] = min(minn[i], minn[j] + (i - j) * val[j]);<br>            }<br>        }<br>        else{<br>            minn[i] = minn[i - 1];<br>        }<br>    }<br>    if(minn[a] &gt;= 1e9) printf(“-1\n”);<br>    else printf(“%lld\n”, minn[a]);<br>}<br>“””</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-06-04</span><i class="fa fa-tag"></i><a class="tag" href="/tags/codeforces/" title="codeforces">codeforces </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2018/06/04/codeforces_988/,Hexo,codeforces#486,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/06/04/codeforces#486/" title="codeforces#486">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/05/05/DenseNet-浅谈/" title="DenseNet-浅谈">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>